<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>circularspace</title><link href="https://mindriot101.github.io/" rel="alternate"></link><link href="https://mindriot101.github.io/feeds/tag_code.xml" rel="self"></link><id>https://mindriot101.github.io/</id><updated>2014-04-23T10:27:49+01:00</updated><entry><title>Using a Makefile for science!</title><link href="https://mindriot101.github.io/blog/2014/04/23/using-a-makefile-for-science/" rel="alternate"></link><updated>2014-04-23T10:27:49+01:00</updated><author><name>Simon Walker</name></author><id>tag:mindriot101.github.io,2014-04-23:blog/2014/04/23/using-a-makefile-for-science/</id><summary type="html">&lt;p&gt;The declarative style of a Makefile (or substitute your own language-of-choice's implementation of *akefiles) lends itself well to scientific processes, where a reproducible method is crucial. I recently found this out when analysing some data, which consisted of the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;compile the source code of the programs I was using&lt;/li&gt;
&lt;li&gt;use these programs on the same data&lt;/li&gt;
&lt;li&gt;plot some summary plots&lt;/li&gt;
&lt;li&gt;show the plots&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With the declarative style of Makefiles I could rely on the latest results no matter what changed in the analysis path, for example the plot scripts used in step 3. were listed as a dependency of the step run to make the plots so when the script changed, the plots would be recreated. &lt;/p&gt;
&lt;p&gt;Another advantage is that step 2. took a long time, so the "update only when the dependency is out of date" style of makefiles really came in handy. I could change the (relatively quick) plotting scripts to my hearts content safe in the knowledge that the data I was using was up to date.&lt;/p&gt;
&lt;p&gt;For scientific analysis, reproducibility is of prime concern, and should I come back to this project at a later date, the combination of a makefile plus the fact that the project was stored in a git repository makes the code easy to use (the readme just contains the line: &lt;code&gt;make&lt;/code&gt;) and consistent.&lt;/p&gt;
&lt;p&gt;A small tip that I did not know before starting out on this endeavour (and is specific to GNU make) is to use &lt;code&gt;$(MAKE)&lt;/code&gt; whenever running make in a subdirectory. This enables parallel job flags (e.g. &lt;code&gt;-j 4&lt;/code&gt;) to be passed down to subsequent make invocations.&lt;/p&gt;
&lt;p&gt;For reference, I was getting the message:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jobserver&lt;/span&gt; &lt;span class="n"&gt;unavailable&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;  &lt;span class="n"&gt;Add&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;rule&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;when calling subtasks with a simple &lt;code&gt;make&lt;/code&gt;. Now with &lt;code&gt;$(MAKE)&lt;/code&gt; the jobs run in parallel where possible.&lt;/p&gt;</summary><category term="make"></category><category term="code"></category><category term="science"></category></entry></feed>