<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>circularspace</title><link href="https://mindriot101.github.io/" rel="alternate"></link><link href="https://mindriot101.github.io/feeds/tag_git.xml" rel="self"></link><id>https://mindriot101.github.io/</id><updated>2014-12-28T23:25:51+00:00</updated><entry><title>git submodules are not so bad</title><link href="https://mindriot101.github.io/blog/2014/12/28/git-submodules-are-not-so-bad/" rel="alternate"></link><updated>2014-12-28T23:25:51+00:00</updated><author><name>Simon Walker</name></author><id>tag:mindriot101.github.io,2014-12-28:blog/2014/12/28/git-submodules-are-not-so-bad/</id><summary type="html">&lt;p&gt;I see a lot of complaints about git submodules, &lt;a href="http://blogs.atlassian.com/2013/05/alternatives-to-git-submodule-git-subtree/"&gt;people suggesting alternatives&lt;/a&gt;, &lt;a href="https://codingkilledthecat.wordpress.com/2012/04/28/why-your-company-shouldnt-use-git-submodules/"&gt;complaints about merging&lt;/a&gt; or other bits and pieces.&lt;/p&gt;
&lt;p&gt;Git submodules &lt;em&gt;have their place&lt;/em&gt;. Yes they are not ideal for all situations but they are ideal for the typical use case I'm about to outline.&lt;/p&gt;
&lt;h2&gt;Example use case&lt;/h2&gt;
&lt;p&gt;In my work I have a &lt;em&gt;master&lt;/em&gt; project which contains multiple submodules. Each submodule is also cloned into a separate &lt;em&gt;development&lt;/em&gt; repository sitting near by. I use the &lt;em&gt;master&lt;/em&gt; repository to synchronise pushes to the deployment server (in this case an isolated computer sitting on a mountain in Chile!)&lt;/p&gt;
&lt;p&gt;Admittedly I have to train myself to follow certain procedures:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Never&lt;/em&gt; perform code alterations or general development in the submodule inside the &lt;em&gt;master&lt;/em&gt; repository.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Only use the &lt;em&gt;master&lt;/em&gt; repository for synchronisation.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Git submodule advantages&lt;/h2&gt;
&lt;p&gt;For my use case I find it very good for the &lt;em&gt;master&lt;/em&gt; repository to track a single &lt;em&gt;commit&lt;/em&gt;, as this bakes in the state of the submodules for each commit of the &lt;em&gt;master&lt;/em&gt; repository. I only need to record the git sha of the &lt;em&gt;master&lt;/em&gt; to be able to recreate the entire source code checkout of the individual packages.&lt;/p&gt;
&lt;p&gt;Development on the individual packages is also easier as they're modularised into separate small, testable directories, and only combined in the &lt;em&gt;master&lt;/em&gt; during a "deployment".&lt;/p&gt;
&lt;p&gt;I can add tests to the &lt;em&gt;master&lt;/em&gt; project that assess the integration between submodules. In the case of an error I can then check out a specific revision in my submodules at will to re-run tests and find breaking changes, perhaps with &lt;code&gt;git bisect&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Git submodule disadvantages&lt;/h2&gt;
&lt;p&gt;The paradigm shift of using submodules is a pain. They require extra, very strange commands to synchronise.&lt;/p&gt;
&lt;p&gt;I have a few git aliases to help me with this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;su = submodule update --init --recursive
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This command initialises and synchronises the submodules in whatever state they started in, either not existing - so a clone takes place - or a previous commit. It also synchronises nested submodules, which I'll admit I would probably never do.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;upsub = submodule foreach &amp;#39;git checkout master &amp;amp;&amp;amp; git pull&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A very useful command, &lt;code&gt;git submodule foreach&lt;/code&gt; runs a command over every submodule specified in the current project. In this case it's used to update the master branch to &lt;code&gt;origin&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A minor annoyance is a submodule with code changes will appear to a git status in the &lt;em&gt;master&lt;/em&gt; as an untracked file, showing the whole submodule as &lt;em&gt;modified&lt;/em&gt;. I personally like this feature as it reminds me that the submodule in the &lt;em&gt;master&lt;/em&gt; is not in a proper state:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;-Subproject commit c74dd1e56794962d7ff7661a7f8ae84cafa96b4f
+Subproject commit c74dd1e56794962d7ff7661a7f8ae84cafa96b4f-dirty
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and therefore shouts at me for forgetting rule 1. above. It can be disabled via: &lt;code&gt;git status --ignore-submodules=dirty&lt;/code&gt; but I do not recommend this. Consider it a &lt;em&gt;feature&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Git subtree&lt;/h2&gt;
&lt;p&gt;A common suggested alternative is &lt;a href="http://git-scm.com/book/en/v1/Git-Tools-Subtree-Merging"&gt;git subtree&lt;/a&gt; which I have tried, though briefly. Perhaps learning submodules from an early stage has ingrained their process in my brain too hard for other alternatives to really show their benefits. As far as I could tell &lt;code&gt;git subtree&lt;/code&gt; creates a huge merge commit in the master repository as a single static blob. I didn't look into coding in the subtrees but I feel the separation of projects afforded by submodules fits my needs better. Perhaps I just have to read the linked article above a bit more.&lt;/p&gt;
&lt;h2&gt;Hints and tips&lt;/h2&gt;
&lt;p&gt;Some hints and tips I always have to google myself:&lt;/p&gt;
&lt;h3&gt;Remove a submodule&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/a/16162000/56711"&gt;source&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git submodule deinit asubmodule
git rm asubmodule
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Summary&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Separate projects and use a &lt;em&gt;master&lt;/em&gt; project to coordinate commits,&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Never&lt;/em&gt; develop in the &lt;em&gt;master&lt;/em&gt;s copy of the repository,&lt;/li&gt;
&lt;li&gt;Use shortcuts to make managing submodules easier.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="git"></category></entry><entry><title>git rebase --skip is fine</title><link href="https://mindriot101.github.io/blog/2014/08/27/git-rebase-skip-is-fine/" rel="alternate"></link><updated>2014-08-27T22:53:48+01:00</updated><author><name>Simon Walker</name></author><id>tag:mindriot101.github.io,2014-08-27:blog/2014/08/27/git-rebase-skip-is-fine/</id><summary type="html">&lt;p&gt;So &lt;code&gt;git rebase&lt;/code&gt; is a powerful tool, able to change history itself. With this power however requires great care to avoid needing to &lt;code&gt;git push --force&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Git rebase comes with very user friendly ways to cancel out of a rebase if something goes wrong or if you become confused:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git rebase --abort
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This returns your working tree back to the state before the rebase was started.&lt;/p&gt;
&lt;p&gt;One thing that has always made me nervous when using rebase was when I rebased and a conflict occured, so I only kept changes from the HEAD commit which caused the following message:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Applying&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;change&lt;/span&gt;
&lt;span class="n"&gt;No&lt;/span&gt; &lt;span class="n"&gt;changes&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;did&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;forget&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;git add&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;there&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;nothing&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;chances&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="n"&gt;already&lt;/span&gt; &lt;span class="n"&gt;introduced&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;same&lt;/span&gt; &lt;span class="n"&gt;changes&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;might&lt;/span&gt; &lt;span class="n"&gt;want&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;skip&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="n"&gt;patch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;When&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;have&lt;/span&gt; &lt;span class="n"&gt;resolved&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="n"&gt;problem&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;git rebase --continue&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;prefer&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;skip&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="n"&gt;patch&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;git rebase --skip&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;instead&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;To&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;original&lt;/span&gt; &lt;span class="n"&gt;branch&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt; &lt;span class="n"&gt;rebasing&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;git rebase --abort&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now I don't like error messages or messages that look like error messages so this result is quite off-putting. In reality the second line of advice, running &lt;code&gt;git rebase --skip&lt;/code&gt; is not a hacky way out of this situation, it's the right answer. skipping a commit when it only includes changes from the HEAD commit is perfectly normal. Once I learned this my time with git was much easier.&lt;/p&gt;</summary><category term="git"></category></entry><entry><title>git quick</title><link href="https://mindriot101.github.io/blog/2013/09/05/git-quick/" rel="alternate"></link><updated>2013-09-05T23:04:00+02:00</updated><author><name>Simon Walker</name></author><id>tag:mindriot101.github.io,2013-09-05:blog/2013/09/05/git-quick/</id><summary type="html">&lt;p&gt;Git quick is a simple shell command I've written for quicker one line messages. It allows committing like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;g q A simple commit message
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note the lack of quotes.  Some things I've used to make it quicker:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;alias git to g in my zshrc&lt;/li&gt;
&lt;li&gt;alias q to quick in my gitconfig file&lt;/li&gt;
&lt;li&gt;put the &lt;code&gt;git-quick&lt;/code&gt; script into my path somewhere&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;The script&lt;/h3&gt;
&lt;p&gt;The script really can't be much simpler:&lt;/p&gt;
&lt;script src="https://gist.github.com/mindriot101/6456980.js"&gt;&lt;/script&gt;

&lt;p&gt;(gisted for quick cloning)&lt;/p&gt;
&lt;p&gt;I only learnt about git cleverly loading any executable &lt;code&gt;git-*&lt;/code&gt; script, and it simply expands any arguments into the commit message.&lt;/p&gt;
&lt;p&gt;Note: this can be even quicker if you alias git quick to a single letter in your zshrc e.g. &lt;code&gt;alias gq='git quick'&lt;/code&gt; or &lt;code&gt;alias q='git quick'&lt;/code&gt; but this seems a bit silly to me. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;WARNING: this increases the likelihood of commit messages like "stuff" or "commit" as it makes it really easy to write short informative messages, so I implore you to use this newly gained power wisely.&lt;/em&gt;&lt;/p&gt;</summary><category term="git"></category></entry><entry><title>Nested gitignore files</title><link href="https://mindriot101.github.io/blog/2013/02/08/nested-gitignore-files/" rel="alternate"></link><updated>2013-02-08T11:39:10+01:00</updated><author><name>Simon Walker</name></author><id>tag:mindriot101.github.io,2013-02-08:blog/2013/02/08/nested-gitignore-files/</id><summary type="html">&lt;p&gt;Today I found out that .gitignore files can be nested.&lt;/p&gt;
&lt;p&gt;For example the directory tree&lt;/p&gt;
&lt;p&gt;a
a/b
.gitignore
a/b/.gitignore&lt;/p&gt;
&lt;p&gt;can have files in b ignored by a/b/.gitignore.&lt;/p&gt;
&lt;p&gt;This helps split the responsibility of ignoring files by topic and really helps organisation!&lt;/p&gt;</summary><category term="git"></category></entry></feed>