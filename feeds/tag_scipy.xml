<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>circularspace</title><link href="https://blog.simonrw.com/" rel="alternate"></link><link href="https://blog.simonrw.com/feeds/tag_scipy.xml" rel="self"></link><id>https://blog.simonrw.com/</id><updated>2014-08-23T10:55:26+01:00</updated><entry><title>Interpolation in Python</title><link href="https://blog.simonrw.com/blog/2014/08/23/interpolation-in-python/" rel="alternate"></link><updated>2014-08-23T10:55:26+01:00</updated><author><name>Simon Walker</name></author><id>tag:blog.simonrw.com,2014-08-23:blog/2014/08/23/interpolation-in-python/</id><summary type="html">&lt;p&gt;For interpolation in python, scipy includes the interpolateackage containing (amongst other things) interp1d for simple interpolation.&lt;/p&gt;
&lt;p&gt;The function does not however perform extrapolation; if the interpolator is asked for a value outside the original range it will raise an exception. To get around this, the interpolator contains a &lt;code&gt;.x&lt;/code&gt; parameter which contains the original &lt;code&gt;x&lt;/code&gt; values used to construct itself. A boolean index can then be used to reject inputoints which fall outside of this range:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# Create an interpolator object from the training dataset
interp = scipy.interpolate.interp1d(data_x, data_y)

# Boolean index array for data points falling within the 
# training dataset range
ind = (new_x &amp;gt; interp.x.min()) &amp;amp; (new_x &amp;lt; interp.x.max())

# Finally create the new interpolated data, remembering
# to apply the index to the x data also
interpolated_x, interpolated_y = new_x[ind], interp(new_x[ind])
&lt;/pre&gt;&lt;/div&gt;</summary><category term="python"></category><category term="scipy"></category></entry></feed>