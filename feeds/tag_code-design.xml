<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>circularspace</title><link href="https://blog.simonrw.com/" rel="alternate"></link><link href="https://blog.simonrw.com/feeds/tag_code-design.xml" rel="self"></link><id>https://blog.simonrw.com/</id><updated>2013-09-04T23:18:00+02:00</updated><entry><title>Null objects for the win</title><link href="https://blog.simonrw.com/blog/2013/09/04/null-objects-for-the-win/" rel="alternate"></link><updated>2013-09-04T23:18:00+02:00</updated><author><name>Simon Walker</name></author><id>tag:blog.simonrw.com,2013-09-04:blog/2013/09/04/null-objects-for-the-win/</id><summary type="html">&lt;p&gt;So I've been watching a lot of OO refactoring screencasts and reading posts and I'm able to say I've implemented some of the advice I've heard. Life's all about learning eh?&lt;/p&gt;
&lt;p&gt;So the main example I want to talk about here is &lt;em&gt;Null objects&lt;/em&gt;. &lt;/p&gt;
&lt;h2&gt;Null objects&lt;/h2&gt;
&lt;p&gt;In dynamic languages, and Ruby in particular&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; the concept of the &lt;em&gt;lack of something&lt;/em&gt; needs to be encapsulated. For example: you're wrapping the database and no entry exists; what to you return? In Ruby it's often &lt;code&gt;nil&lt;/code&gt; but this is not great for app design. This &lt;code&gt;nil&lt;/code&gt; will proliferate through your app causing errors in its wake (&lt;code&gt;NoMethodError&lt;/code&gt;) and causing de-localised stacktraces. Another example is the concept of a guest user. How do you represent this? Subclass the normal User class? &lt;em&gt;&lt;code&gt;nil&lt;/code&gt;&lt;/em&gt;?!
One way to combat this is to introduce Null Objects, where they look like a standard user but don't respond to the methods in the same way.&lt;/p&gt;
&lt;p&gt;My implementation was in Python whilst working on a plotting script. I wanted the option to disable the lower subplot with a given command line argument, so I started adding &lt;code&gt;if&lt;/code&gt; conditions everywhere, which unfortunately was spread all over the code. My recent learning suddenly kicked in and I thought I could create a null axis object (on which all of the plotting commands were being called) which wouldn't respond to any plotting calls.&lt;/p&gt;
&lt;p&gt;In Ruby it's nice and simple to stub out methods, or use metaprogramming. For example by defining a class and a "null" &lt;code&gt;method_missing&lt;/code&gt; method a null object can be created&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;NullAxis&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;method_missing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="no"&gt;NullAxis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;any_method_that_doesnt_exist&lt;/span&gt;
&lt;span class="c1"&gt;# =&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The implementation for Python is almost as simple&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;NullAxis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__getattr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="sd"&gt;        Like Ruby&amp;#39;s `method_missing`, this just returns a &lt;/span&gt;
&lt;span class="sd"&gt;        blank function that does nothing&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;pass&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With this I can leave the axis creation and previous plotting commands intact, but under the condition that the &lt;code&gt;matplotlib&lt;/code&gt; axis object does not exist the code will just silently do nothing.&lt;/p&gt;
&lt;p&gt;This example is small, but I felt good implementing it.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;due to the prevalence of &lt;code&gt;nil&lt;/code&gt;s&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="python"></category><category term="code design"></category></entry></feed>